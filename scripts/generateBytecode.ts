import { createPublicClient, http, isAddress, Address, encodeAbiParameters, parseAbiParameters, keccak256, encodePacked } from 'viem';
import { base } from 'viem/chains';

/**
 * Run: npm run generate-bytecode <poolAddress> [duration] [token0Weight] [token1Weight] [liquidityWeight]
 * 
 * This script generates the inputs needed for setMerklConfigOverride:
 * 1. gauge (address) - from Voter.gauges(poolAddress)
 * 2. token (address) - oHYDX token address
 * 3. config (tuple) - Merkl campaign configuration
 * 
 * Optional parameters:
 * - duration: Campaign duration in seconds (default: 604800 = 7 days)
 * - token0Weight: Weight for token0 (default: 4000 = 40%)
 * - token1Weight: Weight for token1 (default: 4000 = 40%)
 * - liquidityWeight: Weight for liquidity contribution (default: 2000 = 20%)
 * 
 * Note: Weights should sum to 10000 (100%)
 * 
 * Output format ready to paste into Safe Wallet transaction builder
 */

const VOTER_CONTRACT = '0xc69E3eF39E3fFBcE2A1c570f8d3ADF76909ef17b';
const REWARDS_DISTRIBUTOR_CONTRACT = '0xf5E821da09616b4c576f7dfD0D85D28B5B591589';
const OHYDX_TOKEN = '0xA1136031150E50B015b41f1ca6B2e99e49D8cB78';
const MERKL_DISTRIBUTOR = '0x8BB4C975Ff3c250e0ceEA271728547f3802B36Fd';
const CREATOR_ADDRESS = '0x74266f2b206D1359B83fc74949EF07176FB3AE03'; // Admin address
const ZERO_BYTES32 = '0x0000000000000000000000000000000000000000000000000000000000000000';
const DEFAULT_DURATION = 604800; // 7 days in seconds

// ABI for Voter.gauges(address pool) -> address gauge
const VOTER_ABI = [
  {
    inputs: [{ internalType: 'address', name: '', type: 'address' }],
    name: 'gauges',
    outputs: [{ internalType: 'address', name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

// Configuration parameters for Merkl campaign
// Config tuple: (address merklDistributor, bytes32 campaignId, address creator, uint32 campaignType, uint32 duration, bytes campaignData)
interface MerklConfig {
  merklDistributor: Address; // Merkl distributor contract
  campaignId: `0x${string}`; // bytes32 campaign ID (use zero bytes32 for new campaigns)
  creator: Address;          // Address creating the campaign (admin/multisig)
  campaignType: number;      // uint32 - 2 for concentrated liquidity
  duration: number;          // uint32 - campaign duration in seconds
  campaignData: `0x${string}`; // bytes - encoded campaign parameters
}

const client = createPublicClient({
  chain: base,
  transport: http(process.env.RPC_URL),
});

/**
 * Generates the campaign data bytes for a concentrated liquidity campaign
 * Based on Merkl's actual encoding structure from payload.json
 * 
 * Structure: abi.encode(
 *   hydrexPool, propFees, propToken0, propToken1, 
 *   isOutOfRangeIncentivized, boostingAddress, boostedReward,
 *   whitelist, blacklist, extraBytes
 * )
 */
function generateCampaignData(
  poolAddress: Address,
  token0Weight: number = 4000,
  token1Weight: number = 4000,
  liquidityWeight: number = 2000
): `0x${string}` {
  const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
  
  const campaignDataParams = parseAbiParameters([
    'address',      // hydrexPool (the pool address)
    'uint256',      // propFees
    'uint256',      // propToken0
    'uint256',      // propToken1
    'uint256',      // isOutOfRangeIncentivized (0 = false)
    'address',      // boostingAddress
    'uint256',      // boostedReward
    'address[]',    // whitelist
    'address[]',    // blacklist
    'bytes',        // extraData
    'bytes',        // extraData2
    'bytes',        // extraData3
  ].join(','));

  return encodeAbiParameters(campaignDataParams, [
    poolAddress,                 // hydrexPool
    BigInt(liquidityWeight),     // propFees (Liquidity Contribution weight)
    BigInt(token0Weight),        // propToken0 (Token0 weight)
    BigInt(token1Weight),        // propToken1 (Token1 weight)
    BigInt(0),                   // isOutOfRangeIncentivized (0 = false = only in-range positions)
    ZERO_ADDRESS as Address,     // boostingAddress (zero address)
    BigInt(0),                   // boostedReward
    [],                          // whitelist (empty)
    [],                          // blacklist (empty)
    '0x',                        // extraData (empty)
    '0x',                        // extraData2 (empty)
    '0x',                        // extraData3 (empty)
  ]);
}

/**
 * For new campaigns, we use zero bytes32 as the campaign ID
 * The actual campaign ID will be generated by the Merkl contract
 */
function getNewCampaignId(): `0x${string}` {
  return ZERO_BYTES32 as `0x${string}`;
}

async function generateBytecode(
  poolAddress: string,
  duration: number = DEFAULT_DURATION,
  token0Weight: number = 4000,
  token1Weight: number = 4000,
  liquidityWeight: number = 2000
): Promise<void> {
  // Validate input
  if (!isAddress(poolAddress)) {
    console.error('‚ùå Invalid pool address format');
    process.exit(1);
  }

  console.log('\nüîß Generating Merkl Config for pool:', poolAddress);

  try {
    // Get gauge address from Voter contract
    const gaugeAddress = await client.readContract({
      address: VOTER_CONTRACT,
      abi: VOTER_ABI,
      functionName: 'gauges',
      args: [poolAddress as Address],
    });

    if (gaugeAddress === '0x0000000000000000000000000000000000000000') {
      console.error('‚ùå No gauge found for this pool');
      process.exit(1);
    }

    // Validate weights sum to 10000 (100%)
    const totalWeight = token0Weight + token1Weight + liquidityWeight;
    if (totalWeight !== 10000) {
      console.warn(`‚ö†Ô∏è  WARNING: Weights sum to ${totalWeight} instead of 10000 (100%)`);
      console.warn(`   Token0: ${token0Weight}, Token1: ${token1Weight}, Liquidity: ${liquidityWeight}`);
    }
    
    const campaignType = 2; // Concentrated liquidity
    const campaignId = getNewCampaignId();
    
    const campaignData = generateCampaignData(
      poolAddress as Address,
      token0Weight,
      token1Weight,
      liquidityWeight
    );
    
    // Config tuple structure: (address merklDistributor, bytes32 campaignId, address creator, uint32 campaignType, uint32 duration, bytes campaignData)
    const configParams = parseAbiParameters(
      'address, bytes32, address, uint32, uint32, bytes'
    );
    
    const encodedConfig = encodeAbiParameters(configParams, [
      MERKL_DISTRIBUTOR as Address, // merklDistributor
      campaignId,                   // campaignId (zero bytes32 for new campaigns)
      CREATOR_ADDRESS as Address,   // creator (admin address)
      campaignType,                 // campaignType (2 = concentrated liquidity)
      duration,                     // duration in seconds
      campaignData,                 // campaignData (encoded pool config)
    ]);

    // Format config as JSON array for Gnosis Safe
    const configArray = [
      MERKL_DISTRIBUTOR,
      campaignId,
      CREATOR_ADDRESS,
      campaignType,
      duration,
      campaignData
    ];

    // Output results
    console.log('\n' + '='.repeat(80));
    console.log('‚úÖ INPUTS FOR GNOSIS SAFE');
    console.log('='.repeat(80));
    
    console.log('\nContract: RewardsDistributor');
    console.log(`Address: ${REWARDS_DISTRIBUTOR_CONTRACT}`);
    console.log('Method: setMerklConfigOverride(address gauge, address token, tuple config)');
    console.log(`Basescan: https://basescan.org/address/${REWARDS_DISTRIBUTOR_CONTRACT}#writeContract`);
    
    console.log('\n' + '='.repeat(80));
    console.log('COPY-PASTE VALUES BELOW:');
    console.log('='.repeat(80));
    
    console.log('\n1. gauge (address):');
    console.log(gaugeAddress);
    
    console.log('\n2. token (address):');
    console.log(OHYDX_TOKEN);
    
    console.log('\n3. config (tuple):');
    console.log(JSON.stringify(configArray));
    
    console.log('\n' + '='.repeat(80));
    console.log('CONFIG DETAILS:');
    console.log('='.repeat(80));
    console.log(`Pool: ${poolAddress}`);
    console.log(`Gauge: ${gaugeAddress}`);
    console.log(`Duration: ${duration}s (${duration / 86400} days)`);
    console.log(`Weights: Token0=${token0Weight/100}%, Token1=${token1Weight/100}%, Liquidity=${liquidityWeight/100}%`);
    console.log(`Only In-Range: Yes (rewards only in-range positions)`);
    console.log('='.repeat(80) + '\n');

  } catch (error) {
    console.error('\n‚ùå ERROR during generation:');
    console.error(error);
    process.exit(1);
  }
}

// Main execution
if (require.main === module) {
  const poolAddress = process.argv[2];
  const duration = process.argv[3] ? parseInt(process.argv[3]) : DEFAULT_DURATION;
  const token0Weight = process.argv[4] ? parseInt(process.argv[4]) : 4000;
  const token1Weight = process.argv[5] ? parseInt(process.argv[5]) : 4000;
  const liquidityWeight = process.argv[6] ? parseInt(process.argv[6]) : 2000;

  if (!poolAddress) {
    console.error('‚ùå Error: Pool address is required');
    console.error('\nUsage: npm run generate-bytecode <poolAddress> [duration] [token0Weight] [token1Weight] [liquidityWeight]');
    console.error('\nExamples:');
    console.error('  npm run generate-bytecode 0x51f0b932855986b0e621c9d4db6eee1f4644d3d2');
    console.error('  npm run generate-bytecode 0x51f0b932855986b0e621c9d4db6eee1f4644d3d2 604800');
    console.error('  npm run generate-bytecode 0x51f0b932855986b0e621c9d4db6eee1f4644d3d2 604800 4000 4000 2000');
    console.error('\nDefault values:');
    console.error('  duration: 604800 seconds (7 days)');
    console.error('  token0Weight: 4000 (40%)');
    console.error('  token1Weight: 4000 (40%)');
    console.error('  liquidityWeight: 2000 (20%)');
    process.exit(1);
  }

  generateBytecode(poolAddress, duration, token0Weight, token1Weight, liquidityWeight).catch(error => {
    console.error('Generation failed:', error);
    process.exit(1);
  });
}

export { generateBytecode };
